"""
BackupDB SQL Agent - Main CLI Interface
Natural language to SQL query system with autonomous execution and visualization.
"""

import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from tabulate import tabulate

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / 'src'))

from db_manager import DatabaseManager
from sql_agent import SQLAgent, SafetyViolationError
from visualizer import ChartGenerator


class BackupDBAgent:
    """Main application class for the BackupDB SQL Agent."""
    
    def __init__(self):
        """Initialize the agent and all components."""
        self.db_manager = None
        self.sql_agent = None
        self.visualizer = None
        self.schema_cache_path = Path(".agent/context/schema.txt")
        self.current_query_folder = None
        
    def initialize(self):
        """Set up all components and load configuration."""
        print("\n" + "="*80)
        print("ü§ñ BackupDB SQL Agent - Initializing...")
        print("="*80 + "\n")
        
        # Load environment variables
        load_dotenv()
        
        # Get configuration
        db_connection = os.getenv(
            'DB_CONNECTION_STRING',
            'Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=BackupDB;Trusted_Connection=yes;'
        )
        ollama_base_url = os.getenv('OLLAMA_BASE_URL', 'http://localhost:11434')
        ollama_model = os.getenv('OLLAMA_MODEL', 'deepseek-v3.1:671b-cloud')
        max_retries = int(os.getenv('MAX_RETRY_ATTEMPTS', '3'))
        
        print(f"üìã Configuration:")
        print(f"   Database: BackupDB (SQL Server)")
        print(f"   LLM Model: {ollama_model}")
        print(f"   Ollama URL: {ollama_base_url}")
        print(f"   Max Retries: {max_retries}\n")
        
        # Initialize database manager
        print("üîå Connecting to database...")
        try:
            self.db_manager = DatabaseManager(db_connection)
            if not self.db_manager.test_connection():
                raise Exception("Database connection test failed")
        except Exception as e:
            print(f"\n‚ùå Failed to connect to database: {e}")
            print("\nPlease check:")
            print("  1. SQL Server is running")
            print("  2. BackupDB database exists")
            print("  3. ODBC Driver 17 for SQL Server is installed")
            print("  4. Connection string in .env is correct")
            sys.exit(1)
        
        # Load or generate schema
        print("\nüìä Loading database schema...")
        schema_summary = self._load_or_generate_schema()
        
        # Initialize SQL agent
        print("\nüß† Initializing AI agent...")
        try:
            self.sql_agent = SQLAgent(
                db_manager=self.db_manager,
                base_url=ollama_base_url,
                model_name=ollama_model
            )
            self.sql_agent.load_schema_context(schema_summary)
        except Exception as e:
            print(f"\n‚ùå Failed to initialize AI agent: {e}")
            print("\nPlease check:")
            print("  1. Ollama is running (ollama serve)")
            print(f"  2. Model '{ollama_model}' is pulled (ollama pull {ollama_model})")
            print(f"  3. Ollama is accessible at {ollama_base_url}")
            sys.exit(1)
        
        # Initialize visualizer
        print("\nüìà Initializing visualization engine...")
        self.visualizer = ChartGenerator()
        
        print("\n" + "="*80)
        print("‚úÖ BackupDB SQL Agent Ready!")
        print("="*80 + "\n")
    
    def _load_or_generate_schema(self) -> str:
        """Load schema from cache or generate fresh."""
        # Create cache directory if needed
        self.schema_cache_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Check if cache exists
        if self.schema_cache_path.exists():
            print(f"   Loading from cache: {self.schema_cache_path}")
            with open(self.schema_cache_path, 'r', encoding='utf-8') as f:
                schema_summary = f.read()
            print("   ‚úÖ Schema loaded from cache")
        else:
            print("   Extracting schema from database...")
            schema_summary = self.db_manager.get_schema_summary()
            
            # Save to cache
            with open(self.schema_cache_path, 'w', encoding='utf-8') as f:
                f.write(schema_summary)
            print(f"   ‚úÖ Schema cached to: {self.schema_cache_path}")
        
        return schema_summary
    
    def refresh_schema(self):
        """Force refresh of schema cache."""
        print("\nüîÑ Refreshing schema cache...")
        if self.schema_cache_path.exists():
            self.schema_cache_path.unlink()
        schema_summary = self._load_or_generate_schema()
        if self.sql_agent:
            self.sql_agent.load_schema_context(schema_summary)
        print("‚úÖ Schema refreshed!\n")
    
    def _generate_styled_html_table(self, df) -> str:
        """
        Generate a beautifully styled HTML table from DataFrame.
        
        Args:
            df: DataFrame to convert
            
        Returns:
            str: HTML table with inline CSS styling
        """
        # Start HTML table with styling
        html = ['<div style="overflow-x: auto;">']
        html.append('<table style="border-collapse: collapse; width: 100%; font-family: Arial, sans-serif; font-size: 14px;">')
        
        # Table header
        html.append('  <thead>')
        html.append('    <tr style="background-color: #2c3e50; color: white;">')
        for col in df.columns:
            html.append(f'      <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">{col}</th>')
        html.append('    </tr>')
        html.append('  </thead>')
        
        # Table body
        html.append('  <tbody>')
        for idx, row in df.iterrows():
            # Alternate row colors
            bg_color = '#f9f9f9' if idx % 2 == 0 else '#ffffff'
            html.append(f'    <tr style="background-color: {bg_color};">')
            for val in row:
                # Truncate long values
                display_val = str(val)
                if len(display_val) > 50:
                    display_val = display_val[:47] + '...'
                html.append(f'      <td style="border: 1px solid #ddd; padding: 10px; text-align: left;">{display_val}</td>')
            html.append('    </tr>')
        html.append('  </tbody>')
        
        html.append('</table>')
        html.append('</div>')
        
        return '\n'.join(html)
    
    def _save_result_to_file(self, user_query: str, sql: str, df) -> str:
        """
        Save query results to files in a dedicated folder.
        
        Args:
            user_query: Original user question
            sql: SQL query executed
            df: Results DataFrame
            
        Returns:
            str: Path to saved markdown file
        """
        from datetime import datetime
        
        # Generate timestamp for folder name
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Create query-specific folder
        query_folder = Path(f"artifacts/query_{timestamp}")
        query_folder.mkdir(parents=True, exist_ok=True)
        
        # Define file paths
        md_filepath = query_folder / "result.md"
        csv_filepath = query_folder / "result.csv"
        
        # Save CSV for easy viewing in Excel
        df.to_csv(csv_filepath, index=False, encoding='utf-8-sig')
        
        # Build markdown content
        content = []
        content.append("# SQL Query Result")
        content.append(f"\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        content.append(f"**Query Folder:** `{query_folder.name}`")
        content.append(f"\n---\n")
        
        content.append("## User Question")
        content.append(f"\n```\n{user_query}\n```\n")
        
        content.append("## SQL Query")
        content.append(f"\n```sql\n{sql}\n```\n")
        
        content.append(f"## Results\n")
        content.append(f"**Total Rows:** {len(df)}")
        content.append(f"**Total Columns:** {len(df.columns)}\n")
        
        # Add file reference
        content.append(f"> üí° **Files in this folder:**")
        content.append(f"> - `result.md` - This file with formatted table")
        content.append(f"> - `result.csv` - Full data in CSV format")
        content.append(f"> - `chart.png` - Visualization (if generated)\n")
        
        # Prepare display DataFrame
        df_display = df.fillna('')
        
        # Format the full table with HTML for better styling
        content.append(f"### Data Table\n")
        
        # Generate HTML table with styling
        html_table = self._generate_styled_html_table(df_display)
        content.append(html_table)
        
        # Also add a clean markdown version for compatibility
        content.append("\n\n<details>")
        content.append("<summary>üìã Click to view plain markdown table</summary>\n")
        try:
            from tabulate import tabulate
            table_md = tabulate(
                df_display,
                headers='keys',
                tablefmt='github',
                showindex=False,
                maxcolwidths=40
            )
            content.append(table_md)
        except:
            content.append(df_display.to_markdown(index=False, max_colwidth=40))
        content.append("\n</details>")
        
        # Write markdown file
        with open(md_filepath, 'w', encoding='utf-8') as f:
            f.write('\n'.join(content))
        
        # Store folder path for chart generation
        self.current_query_folder = query_folder
        
        return str(md_filepath)
    
    def run_query(self, user_query: str):
        """Execute a user query with visualization."""
        try:
            # Execute with retry logic
            df, sql = self.sql_agent.execute_with_retry(user_query)
            
            # Display SQL used
            print(f"\nüìù SQL Query Used:")
            print("-" * 80)
            print(sql)
            print("-" * 80)
            
            # Display results
            print(f"\nüìä Results ({len(df)} rows):")
            print("-" * 80)
            
            if df.empty:
                print("No results found.")
            else:
                # Prepare DataFrame for display
                # Replace None/NaN values with empty string for better tabulate compatibility
                df_display = df.fillna('')
                
                # Limit preview to first 20 rows for large datasets
                preview_limit = 20
                if len(df_display) > preview_limit:
                    df_preview = df_display.head(preview_limit)
                    print(f"Showing first {preview_limit} of {len(df)} rows:")
                else:
                    df_preview = df_display
                
                # Format table with tabulate
                try:
                    table = tabulate(
                        df_preview,
                        headers='keys',
                        tablefmt='grid',
                        showindex=False,
                        maxcolwidths=30
                    )
                    print(table)
                except Exception as e:
                    # Fallback to simple display if tabulate fails
                    print(f"‚ö†Ô∏è  Table formatting error, showing raw data:")
                    print(df_preview.to_string(max_rows=preview_limit, max_colwidth=30))
            
            print("-" * 80)
            
            # Save results to file
            if not df.empty:
                result_file = self._save_result_to_file(user_query, sql, df)
                query_folder = self.current_query_folder
                print(f"\nüíæ Results saved to folder: {query_folder.name}/")
                print(f"   üìÑ result.md  - Formatted report")
                print(f"   üìä result.csv - Full data")
            
            # Try to generate visualization
            if not df.empty:
                chart_path = self.visualizer.auto_visualize(df, user_query)
                if chart_path:
                    # Move chart to query folder
                    import shutil
                    chart_filename = Path(chart_path).name
                    new_chart_path = self.current_query_folder / "chart.png"
                    shutil.move(chart_path, new_chart_path)
                    print(f"   üìà chart.png  - Visualization")
            
        except SafetyViolationError as e:
            print(f"\n{e}\n")
        except Exception as e:
            print(f"\n‚ùå Error: {e}\n")
    
    def interactive_loop(self):
        """Main interactive query loop."""
        print("üí¨ Enter your questions in natural language")
        print("   Commands: 'exit' or 'quit' to exit, 'refresh' to reload schema\n")
        
        while True:
            try:
                # Get user input
                user_input = input("‚ùì Ask a question: ").strip()
                
                if not user_input:
                    continue
                
                # Check for commands
                if user_input.lower() in ['exit', 'quit', 'q']:
                    print("\nüëã Goodbye!")
                    break
                
                if user_input.lower() == 'refresh':
                    self.refresh_schema()
                    continue
                
                # Run query
                self.run_query(user_input)
                print()  # Blank line for readability
                
            except KeyboardInterrupt:
                print("\n\nüëã Goodbye!")
                break
            except Exception as e:
                print(f"\n‚ùå Unexpected error: {e}\n")
    
    def cleanup(self):
        """Clean up resources."""
        if self.db_manager:
            self.db_manager.close()


def main():
    """Main entry point."""
    agent = BackupDBAgent()
    
    try:
        agent.initialize()
        agent.interactive_loop()
    finally:
        agent.cleanup()


if __name__ == "__main__":
    main()
